---
sidebar_position: 5
title: Proyectos - Comunicaciones en Red
---

# Proyectos: Juegos Multijugador en Red con Kotlin

Estos proyectos tienen como objetivo consolidar los conocimientos sobre la comunicaci√≥n en red utilizando Sockets TCP en Kotlin. Cada proyecto consiste en un juego con servidor central que gestiona m√∫ltiples clientes simult√°neamente, con opciones de juego PVE (Player vs Environment/IA) y PVP (Player vs Player).

:::info Nota importante
Se proponen 5 proyectos de juegos. Todos deben desarrollarse como aplicaciones **Kotlin Multiplatform (KMP)** con soporte para **Escritorio (Windows)**. Cada proyecto incluye un servidor que gestiona las partidas y almacena estad√≠sticas.
:::

:::tip Requisitos Comunes para Todos los Proyectos
Todos los proyectos deben cumplir con los siguientes requisitos t√©cnicos:

### Configuraci√≥n del Servidor
- **Archivo de Configuraci√≥n (`server.properties`)**: El servidor debe leer la configuraci√≥n de red desde un archivo que contenga:
  ```properties
  server.host=localhost
  server.port=5678
  max.clients=10
  ```

### Sistema de Records
- **Almacenamiento de Records (`records.json`)**: El servidor debe mantener un archivo con las mejores puntuaciones y estad√≠sticas:
  - Mejores puntuaciones por jugador
  - Partidas ganadas/perdidas
  - Rachas de victorias
  - Estad√≠sticas espec√≠ficas de cada juego
- **Sincronizaci√≥n de Records**: Al conectarse, los clientes deben descargar el archivo de records del servidor para mostrarlos en el men√∫ principal

### Men√∫ Principal del Cliente
Todos los clientes deben incluir un men√∫ con las siguientes opciones:
1. **Nueva Partida PVP** (contra otro jugador)
2. **Nueva Partida PVE** (contra la IA del servidor)
3. **Ver Records** (mostrar estad√≠sticas descargadas del servidor)
4. **Configuraci√≥n** (n√∫mero de rondas, dificultad, etc.)
5. **Salir**

### Comunicaci√≥n Cliente-Servidor
- Uso de **Sockets TCP** para garantizar que todos los mensajes lleguen en orden
- Protocolo de comunicaci√≥n basado en JSON usando `kotlinx.serialization`
- El servidor valida toda la l√≥gica del juego para evitar trampas
- Manejo de m√∫ltiples clientes concurrentes usando corrutinas

### Interfaz Gr√°fica (Compose Multiplatform)
- Uso de Compose for Desktop para crear interfaces gr√°ficas modernas
- Interfaz responsive adaptada para Windows Desktop
- Feedback visual claro de las acciones del jugador y del oponente
:::

---

## Proyecto 1: Hundir la Flota (Batalla Naval) üö¢

**Plataformas:** Kotlin Multiplatform (Escritorio Windows)

### Descripci√≥n

Desarrolla el cl√°sico juego de "Hundir la Flota" para jugar online contra otro oponente (PVP) o contra la IA del servidor (PVE). Los jugadores colocan sus barcos en una cuadr√≠cula y por turnos intentan hundir la flota enemiga. La l√≥gica del juego se valida en el servidor para evitar trampas.

### Funcionalidades Espec√≠ficas

#### Configuraci√≥n del Juego
- **Tama√±o del tablero**: 10x10 (configurable)
- **Flota disponible**:
  - 1 Portaaviones (5 casillas)
  - 2 Acorazados (4 casillas)
  - 3 Cruceros (3 casillas)
  - 4 Destructores (2 casillas)
- **N√∫mero de rondas**: Configurable (mejor de 1, 3 o 5 partidas)
- **Tiempo por turno**: 60 segundos (configurable)

#### Comunicaci√≥n y Red
1. **Lobby**: Los jugadores pueden crear o unirse a salas de espera. En PVE, la partida comienza inmediatamente.
2. **Protocolo de Juego** (ejemplos):
   - `PLACE_SHIP:{"ship":"CARRIER","positions":["A1","A2","A3","A4","A5"]}`
   - `ATTACK:{"position":"C4"}`
   - `ATTACK_RESULT:{"position":"C4","result":"HIT","sunk":false}`
   - `ATTACK_RESULT:{"position":"E5","result":"MISS"}`
   - `GAME_OVER:{"winner":"Player1","reason":"ALL_SHIPS_SUNK"}`
3. **Sistema de turnos**: El servidor gestiona de qui√©n es el turno y notifica a ambos clientes.

#### Interfaz Gr√°fica
- **Fase de Colocaci√≥n**: Tablero interactivo donde el jugador coloca sus barcos (arrastrar y rotar)
- **Fase de Combate**: Dos tableros lado a lado
  - **Mi Flota**: Muestra tus barcos y los impactos recibidos
  - **Radar Enemigo**: Cuadr√≠cula donde realizas tus ataques (muestra impactos y agua)
- **Indicadores**: 
  - Barcos restantes de cada jugador
  - Turno actual
  - Tiempo restante para el movimiento
- **Historial de movimientos**: Lista de los √∫ltimos ataques realizados

#### Records y Estad√≠sticas
- Partidas ganadas/perdidas (PVP y PVE por separado)
- Racha de victorias m√°s larga
- Mejor precisi√≥n de disparos (impactos/disparos totales)
- Partidas m√°s r√°pidas (menor n√∫mero de turnos para ganar)

---

## Proyecto 2: Wordle Multijugador üî§

**Plataformas:** Kotlin Multiplatform (Escritorio Windows)

### Descripci√≥n

Adaptaci√≥n del popular juego Wordle a modo multijugador. Los jugadores compiten para adivinar una palabra de 5 letras en el menor n√∫mero de intentos. En modo PVP, gana quien adivine primero o con menos intentos. En modo PVE, se juega contra el r√©cord del tiempo del servidor.

### Funcionalidades Espec√≠ficas

#### Configuraci√≥n del Juego
- **Longitud de palabra**: 5 letras (opcionalmente 4, 6 o 7)
- **N√∫mero de intentos**: 6 intentos m√°ximo (configurable)
- **N√∫mero de rondas**: Configurable (mejor de 3, 5 o 7 palabras)
- **Diccionario**: El servidor mantiene una lista de palabras v√°lidas
- **Dificultad PVE**: F√°cil (palabras comunes), Media, Dif√≠cil (palabras raras)
- **Tiempo por palabra**: 3 minutos m√°ximo (opcional)

#### Comunicaci√≥n y Red
1. **Inicio de Partida**: 
   - `START_GAME:{"mode":"PVP","rounds":5,"wordLength":5}`
   - El servidor selecciona la palabra a adivinar
2. **Protocolo de Juego**:
   - `GUESS:{"word":"PERRO","attempt":1}`
   - `GUESS_RESULT:{"word":"PERRO","result":[{"letter":"P","status":"CORRECT"},{"letter":"E","status":"PRESENT"},{"letter":"R","status":"ABSENT"}...]}`
   - Estados: `CORRECT` (letra correcta en posici√≥n correcta), `PRESENT` (letra existe pero en otra posici√≥n), `ABSENT` (letra no existe)
   - `ROUND_WINNER:{"player":"Player1","attempts":4,"word":"PERRO"}`
3. **Validaci√≥n**: El servidor valida que las palabras existan en el diccionario

#### Interfaz Gr√°fica
- **Cuadr√≠cula de intentos**: 6 filas x 5 columnas mostrando cada intento con colores:
  - Verde: letra correcta en posici√≥n correcta
  - Amarillo: letra existe en la palabra pero en otra posici√≥n
  - Gris: letra no existe en la palabra
- **Teclado virtual**: Teclado QWERTY que muestra el estado de cada letra ya probada
- **Panel de estado**:
  - Intentos restantes
  - Tiempo transcurrido
  - En PVP: progreso del oponente (n√∫mero de intentos realizados)
- **Contador de rondas**: Muestra las rondas ganadas por cada jugador

#### Records y Estad√≠sticas
- Partidas ganadas/perdidas
- Distribuci√≥n de intentos (en cu√°ntos intentos sueles acertar)
- Racha de victorias actual y m√°xima
- Tiempo promedio por palabra
- Porcentaje de palabras adivinadas

---

## Proyecto 3: Tres en Raya (Tic-Tac-Toe) ‚ùå‚≠ï

**Plataformas:** Kotlin Multiplatform (Escritorio Windows)

### Descripci√≥n

Implementaci√≥n del cl√°sico juego de Tres en Raya con m√∫ltiples variantes y niveles de dificultad en la IA. Los jugadores compiten en modo PVP o PVE para conseguir alinear 3 s√≠mbolos en un tablero.

### Funcionalidades Espec√≠ficas

#### Configuraci√≥n del Juego
- **Tama√±o del tablero**: 3x3 (cl√°sico), 4x4, 5x5
  - En 4x4: gana quien alinee 4
  - En 5x5: gana quien alinee 5
- **N√∫mero de partidas**: Mejor de 3, 5 o de 7
- **Dificultad IA (PVE)**: 
  - F√°cil: movimientos aleatorios
  - Medio: minimax con profundidad limitada
  - Dif√≠cil: minimax completo (invencible en 3x3)
- **Tiempo por movimiento**: 30 segundos (configurable)
- **Modo Turbo**: Partidas r√°pidas con tiempo limitado (10 segundos por turno)

#### Comunicaci√≥n y Red
1. **Configuraci√≥n de Partida**:
   - `CREATE_GAME:{"boardSize":3,"rounds":5,"difficulty":"HARD","timeLimit":30}`
2. **Protocolo de Juego**:
   - `MAKE_MOVE:{"position":{"row":1,"col":2}}`
   - `MOVE_RESULT:{"player":"X","position":{"row":1,"col":2},"valid":true}`
   - `GAME_STATE:{"board":[["X","O",""],["","X",""],["","","O"]],"nextPlayer":"X"}`
   - `ROUND_END:{"winner":"X","winningLine":[{"row":0,"col":0},{"row":1,"col":1},{"row":2,"col":2}]}`
   - `MATCH_END:{"winner":"Player1","score":{"player1":3,"player2":1}}`

#### Interfaz Gr√°fica
- **Tablero interactivo**: Cuadr√≠cula de NxN donde hacer clic coloca tu s√≠mbolo
- **Animaciones**:
  - Aparici√≥n de s√≠mbolos (X y O)
  - L√≠nea animada cuando hay victoria
  - Tablero que se sacude en caso de empate
- **Marcador de partidas**: Muestra el resultado de cada ronda
- **Indicador de turno**: Claramente visible de qui√©n es el turno
- **Historial de movimientos**: Lista de movimientos realizados con opci√≥n de deshacer (solo en modo pr√°ctica)
- **Timer**: Cuenta regresiva del tiempo restante para el movimiento

#### Records y Estad√≠sticas
- Partidas ganadas/perdidas/empates (PVP y PVE separados)
- Victorias por tama√±o de tablero
- R√©cord de victorias consecutivas
- Tiempo promedio por movimiento
- Porcentaje de victorias contra cada nivel de IA
- Movimiento favorito (posici√≥n m√°s jugada)

---

## Proyecto 4: Blackjack Multijugador üÉè

**Plataformas:** Kotlin Multiplatform (Escritorio Windows)

### Descripci√≥n

Implementaci√≥n del popular juego de cartas Blackjack (21). M√∫ltiples jugadores pueden jugar simult√°neamente contra la banca (servidor). En modo PVP, los jugadores compiten entre s√≠ para ver qui√©n obtiene mejor mano. En modo PVE, el jugador juega individualmente contra la banca.

### Funcionalidades Espec√≠ficas

#### Configuraci√≥n del Juego
- **N√∫mero de mazos**: 1, 2 o 4 mazos (configurable)
- **Apuesta inicial**: Sistema de fichas virtuales (cada jugador comienza con 1000 fichas)
- **N√∫mero de rondas**: Hasta agotar fichas o n√∫mero fijo de manos
- **Reglas configurables**:
  - Blackjack paga 3:2 o 6:5
  - Banca se planta en 17 blando o 17 duro
  - Permitir doblar despu√©s de dividir
  - Permitir rendici√≥n (surrender)
  - N√∫mero m√°ximo de divisiones (splits)

#### Comunicaci√≥n y Red
1. **Inicio de Partida**:
   - `JOIN_TABLE:{"playerName":"Player1","buyIn":1000}`
   - `TABLE_STATE:{"players":[...],"dealer":"Dealer","minBet":10,"maxBet":500}`
2. **Protocolo de Juego**:
   - `PLACE_BET:{"amount":50}`
   - `DEAL:{"playerHand":[{"rank":"K","suit":"HEARTS"},{"rank":"7","suit":"DIAMONDS"}],"dealerUpCard":{"rank":"A","suit":"SPADES"}}`
   - `HIT:{}` - Pedir carta
   - `STAND:{}` - Plantarse
   - `DOUBLE:{}` - Doblar apuesta
   - `SPLIT:{}` - Dividir pareja
   - `SURRENDER:{}` - Rendirse
   - `CARD_DEALT:{"card":{"rank":"Q","suit":"CLUBS"},"handValue":17}`
   - `HAND_RESULT:{"result":"WIN","payout":100,"finalHand":[...],"dealerHand":[...]}`
   - Resultados: `WIN`, `LOSE`, `PUSH` (empate), `BLACKJACK`

#### Interfaz Gr√°fica
- **Mesa de Blackjack**: Vista que simula una mesa de casino
  - Zona del dealer en la parte superior
  - Zona del jugador en la parte inferior
  - Hasta 5 posiciones de jugadores en modo multijugador
- **Cartas visuales**: Im√°genes o representaciones gr√°ficas de las cartas
- **Botones de acci√≥n**: Hit, Stand, Double, Split, Surrender (habilitados seg√∫n reglas)
- **Contador de fichas**: Muestra las fichas disponibles y la apuesta actual
- **Estad√≠sticas en vivo**:
  - Valor de la mano actual
  - Conteo b√°sico (opcional, para pr√°ctica)
  - Probabilidades de pasarse
- **Historial de manos**: √öltimas 10 manos jugadas con resultados

#### Records y Estad√≠sticas
- Fichas m√°ximas alcanzadas
- Racha de victorias m√°s larga
- N√∫mero de Blackjacks naturales obtenidos
- Porcentaje de victorias
- Ganancia/p√©rdida total (en fichas)
- Mejor mano (ej: 5 cartas sin pasarse)
- Estad√≠sticas por decisi√≥n (% de veces que Hit, Stand, Double, etc.)

---

## Proyecto 5: Trivial Multijugador üéØ

**Plataformas:** Kotlin Multiplatform (Escritorio Windows)

### Descripci√≥n

Juego de preguntas y respuestas tipo trivial. Los jugadores compiten respondiendo preguntas de diferentes categor√≠as. En modo PVP, gana quien responda m√°s preguntas correctamente. En modo PVE, el jugador intenta superar su mejor puntuaci√≥n.

### Funcionalidades Espec√≠ficas

#### Configuraci√≥n del Juego
- **N√∫mero de preguntas**: Configurable (3, 5, 10, 20 preguntas)
- **Categor√≠as disponibles**:
  - Historia
  - Ciencia y Naturaleza
  - Deportes
  - Geograf√≠a
  - Arte y Literatura
  - Entretenimiento (Cine, M√∫sica, TV)
  - Tecnolog√≠a
  - Conocimiento General
- **Dificultad**: F√°cil, Media, Dif√≠cil, Mixta
- **Modo de juego**:
  - **Por Turnos**: Los jugadores responden alternadamente
  - **Simult√°neo**: Todos ven la misma pregunta y el primero en responder gana puntos
  - **Contrarreloj**: Cada pregunta tiene tiempo l√≠mite (10, 15 o 30 segundos)
- **Sistema de puntuaci√≥n**:
  - Respuesta correcta: +10 puntos (x1.5 si es dif√≠cil, x2 si es muy dif√≠cil)
  - Respuesta incorrecta: 0 puntos
  - Bonus por velocidad: +5 puntos si respondes en menos de 5 segundos
  - Racha: Multiplicador x2 a partir de 5 respuestas correctas seguidas

#### Comunicaci√≥n y Red
1. **Configuraci√≥n de Partida**:
   - `CREATE_TRIVIA:{"mode":"PVP","questions":30,"categories":["SCIENCE","HISTORY"],"difficulty":"MIXED","timeLimit":15}`
2. **Protocolo de Juego**:
   - `QUESTION:{"id":1,"category":"SCIENCE","difficulty":"MEDIUM","question":"¬øCu√°l es el planeta m√°s grande del sistema solar?","options":["J√∫piter","Saturno","Neptuno","Urano"],"timeLimit":15}`
   - `ANSWER:{"questionId":1,"selectedOption":0,"timeElapsed":8}`
   - `ANSWER_RESULT:{"questionId":1,"correct":true,"correctAnswer":0,"points":15,"explanation":"J√∫piter es el planeta m√°s grande con un di√°metro de 139,820 km"}`
   - `SCORE_UPDATE:{"players":[{"name":"Player1","score":85,"streak":5},{"name":"Player2","score":70,"streak":0}]}`
   - `GAME_END:{"winner":"Player1","finalScores":[...],"correctAnswers":{"Player1":17,"Player2":14}}`

#### Interfaz Gr√°fica
- **Pantalla de pregunta**:
  - N√∫mero de pregunta actual
  - Categor√≠a e icono
  - Pregunta claramente visible
  - 4 opciones de respuesta (botones grandes)
  - Barra de progreso del tiempo restante
- **Feedback inmediato**:
  - Color verde si la respuesta es correcta
  - Color rojo si es incorrecta, con la respuesta correcta destacada
  - Explicaci√≥n breve de la respuesta
- **Panel de puntuaci√≥n**:
  - Puntos de cada jugador
  - Racha actual
  - Preguntas respondidas correctamente
- **Indicadores visuales**:
  - Animaci√≥n de racha cuando alcanzas 5+ correctas
  - Efectos de sonido para respuestas correctas/incorrectas
- **Progreso**: Barra que muestra cu√°ntas preguntas quedan

#### Base de Datos de Preguntas
El servidor debe mantener un archivo JSON con la base de preguntas:
```json
{
  "questions": [
    {
      "id": 1,
      "category": "SCIENCE",
      "difficulty": "EASY",
      "question": "¬øCu√°ntos planetas hay en el sistema solar?",
      "options": ["7", "8", "9", "10"],
      "correctAnswer": 1,
      "explanation": "Desde 2006, el sistema solar tiene 8 planetas tras la reclasificaci√≥n de Plut√≥n."
    }
  ]
}
```

#### Records y Estad√≠sticas
- Puntuaci√≥n m√°xima alcanzada
- Racha m√°s larga de respuestas correctas
- Porcentaje de aciertos por categor√≠a
- Porcentaje de aciertos por dificultad
- Tiempo promedio de respuesta
- Preguntas respondidas correctamente en total
- Categor√≠a favorita (mejor % de aciertos)
- Ranking de mejores jugadores del servidor

---

:::tip Banco de preguntas
Es posible sacar las preguntas de APIs p√∫blicas como [Open Trivia DB](https://opentdb.com/) o crear un archivo JSON propio con al menos 100 preguntas variadas.
:::

## Requisitos T√©cnicos Generales para Todos los Proyectos

### Arquitectura del Servidor

```kotlin
// Ejemplo de estructura del servidor
class GameServer(configFile: String) {
    private val config = loadConfig(configFile) // Lee server.properties
    private val records = RecordsManager("records.json")
    private val clients = mutableListOf<ClientHandler>()
    
    fun start() {
        val serverSocket = ServerSocket(config.port, 50, InetAddress.getByName(config.host))
        // Aceptar clientes y gestionar concurrencia con corrutinas
    }
    
    suspend fun handleClient(socket: Socket) {
        // Gesti√≥n de cada cliente
    }
}
```

### Gesti√≥n de Records

Cada servidor debe implementar:
- Lectura/escritura de records en formato JSON
- Actualizaci√≥n de records al finalizar partidas
- Env√≠o de records a clientes cuando se conectan
- Persistencia ante ca√≠das del servidor

### Cliente KMP

```kotlin
// C√≥digo compartido entre plataformas
expect class NetworkClient {
    suspend fun connect(host: String, port: Int)
    suspend fun send(message: String)
    suspend fun receive(): String
}

// L√≥gica de negocio compartida
class GameClient(private val network: NetworkClient) {
    suspend fun downloadRecords(): Records {
        // Descargar records del servidor
    }
    
    suspend fun startGame(mode: GameMode) {
        // Iniciar partida
    }
}
```

### Interfaz de Usuario

- Usar **Compose Multiplatform** para compartir c√≥digo de UI
- Implementar navegaci√≥n entre pantallas (men√∫, juego, records, configuraci√≥n)
- Manejar estados de carga, error y √©xito
- Adaptar layouts para diferentes tama√±os de pantalla

### Manejo de Errores y Desconexiones

- Reconexi√≥n autom√°tica en caso de p√©rdida de red
- Timeout en operaciones de red
- Guardado de estado de la partida en curso
- Mensajes de error claros para el usuario

---

## Entregables

Para cada proyecto se debe entregar:

1. **C√≥digo Fuente**:
   - Servidor (aplicaci√≥n Kotlin)
   - Cliente KMP (con soporte Desktop Windows)
   - C√≥digo com√∫n compartido
   - Repositorio Git con historial de commits en GitHub, GitLab o similar

2. **Archivos de Configuraci√≥n**:
   - `server.properties` con valores de ejemplo
   - `records.json` con estructura inicial
   - Base de datos de preguntas (para el Trivial)

3. **Documentaci√≥n**:
   - README con instrucciones de compilaci√≥n y ejecuci√≥n
   - Documentaci√≥n del protocolo de comunicaci√≥n
   - Diagrama de arquitectura
   - Manual de usuario
   - Todo esto debe estar contenido en el README.md del repositorio

4. **V√≠deo Demostraci√≥n** (5-10 minutos):
   - Explicaci√≥n del proyecto y la arquitectura de red
   - Explicaci√≥n de la arquitectura del c√≥digo elegida
   - Funcionamiento del servidor con m√∫ltiples clientes
   - Modo PVP y PVE
   - Sistema de records
   - Configuraci√≥n del juego

---

## Criterios de Evaluaci√≥n

Cada proyecto ser√° evaluado seg√∫n:

- **Funcionalidad (40%)**:
  - El juego funciona correctamente
  - Modos PVP y PVE implementados
  - Sistema de records operativo
  - Configuraci√≥n desde archivos

- **Comunicaci√≥n en Red (30%)**:
  - Protocolo bien dise√±ado
  - Gesti√≥n correcta de m√∫ltiples clientes
  - Manejo de errores y desconexiones
  - Validaci√≥n de datos en el servidor

- **Interfaz de Usuario (15%)**:
  - UI clara e intuitiva
  - Feedback visual apropiado
  - Interfaz optimizada para Desktop Windows
  - Buena experiencia de usuario

- **C√≥digo y Arquitectura (15%)**:
  - C√≥digo limpio y organizado
  - Uso apropiado de corrutinas
  - Compartici√≥n de c√≥digo KMP
  - Gesti√≥n de estados

---

## Consejos y Recomendaciones

1. **Comienza por el protocolo**: Define claramente los mensajes entre cliente y servidor antes de implementar
2. **Prueba con m√∫ltiples clientes**: Usa varias instancias del cliente para probar la concurrencia
3. **Implementa PVE primero**: Es m√°s f√°cil y te permite validar la l√≥gica antes de a√±adir PVP
4. **Usa librer√≠as de serializaci√≥n**: `kotlinx.serialization` facilita mucho el trabajo con JSON
5. **Logging**: Implementa logs tanto en cliente como servidor para facilitar la depuraci√≥n
6. **Testing**: Prueba casos l√≠mite (desconexiones, timeout, datos inv√°lidos)
7. **Versionado**: Usa Git desde el inicio y haz commits frecuentes

¬°Buena suerte con los proyectos!
